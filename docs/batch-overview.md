# Batch Application Overview

This project demonstrates a minimal Spring Batch pipeline that streams JSON from REST APIs into a relational database. It runs on an H2 database configured for Oracle compatibility so the same JPA mappings work against a real Oracle instance.

## Components

### Entities
- **User** – individuals in the system.
- **Group** – logical collections of users.
- **VisibilityProfile** – permissions that control what a user can see.
- **SubmissionType** – reference data for submissions.
- **VpGroupLink** – join entity linking visibility profiles to groups with a role.

### DTOs
DTO records mirror the JSON structure returned by the remote endpoints. They are deserialized by Jackson and then translated into entities by item processors.

### Processors
Each JSON type has an `ItemProcessor` that converts it into its corresponding JPA entity. Relationships are created on the fly; for example, `UserProcessor` attaches users to groups and visibility profiles as it processes records.

### Streaming Reader
`RedOakStreamReader` requests a JSON array from a given endpoint and streams each element without loading the whole response into memory. It emits DTO instances to the step.

### Job & Steps
`JobConfig` wires three steps:
1. **loadUsers** – reads the users endpoint, processes each item, and writes users.
2. **loadGroups** – reads groups and writes groups.
3. **loadVPs** – reads visibility profiles and writes them along with their links and submission types.
Steps share a generic JPA writer that persists entities using Spring Data JPA.

## Data Flow Example
1. The job starts `loadUsers`.
2. `RedOakStreamReader` sends a GET request with a bearer token obtained from `TokenService` and begins streaming the JSON array.
3. Each `UserJson` DTO is passed to `UserProcessor`, which builds a `User` entity and resolves group/visibility profile references.
4. The writer flushes batches of entities to the H2 database.
5. After users are loaded, the job proceeds with groups and visibility profiles in the same manner.

Conceptually, a single user item flows as:
`[REST endpoint] → [RedOakStreamReader] → UserJson → [UserProcessor] → User → [JPA writer] → database`

## Quick Start
1. Build once to download dependencies:
   ```bash
   ./gradlew bootJar
   ```
2. Run the batch job:
   ```bash
   ./gradlew bootRun
   ```
   This creates `./data/redoak.mv.db` and executes all three steps.
3. Browse `http://localhost:8080/h2` using JDBC URL `jdbc:h2:file:./data/redoak` to inspect the tables.

## Switching to Oracle
Update `application.properties`:
```properties
spring.datasource.url=jdbc:oracle:thin:@//db-host:1521/ORCLCDB
spring.datasource.username=myuser
spring.datasource.password=mypass
spring.datasource.driver-class-name=oracle.jdbc.driver.OracleDriver
```
Ensure the Oracle JDBC driver is on the classpath. The schema generated by Hibernate works for both H2 (in Oracle mode) and real Oracle databases.
